JVM

## java 从编码到执行

* 从虚拟机视角来看，执行 java 代码首先需要将它编译而成的 class 文件加载到虚拟机中。

* **加载后的 Java 类会被存放在方法区中，实际运行时，虚拟机会执行方法区内的代码**

* Java 虚拟机在内存中划分出堆和栈存储运行时的数据，进一步，栈会细分为面向 Java 方法的 **Java方法栈**和 用 C++ 写的 native 方法的**本地方法栈**
* 在运行过程中，每当调用一个 Java 方法，Java 虚拟机会在**当前线程**的 **Java 方法栈**中生成一个栈帧，用以**存放局部变量以及字节码操作数**，这个栈帧大小是提前计算好的，不要求栈帧在内存中连续分布
  * 栈帧有两个主要的组成部分，**局部变量区(等价一维数组)和字节码的操作数栈**
* 退出方法的时候，弹出栈帧，将之舍弃

<img src="https://s2.loli.net/2022/08/13/zFdxa6uT9phkNeD.png" alt="image-20220813152256726" style="zoom:50%;" />

* 解释执行的优点在于无需等待编译，JIT 编译执行优势在于速度更快，Hotpot默认采用混合模式
* 即时编译后的 Java 程序的运行效率有可能超过 C++ 程序。这是因为与静态编译相比，即时编译拥有程序的运行信息，并且能够根据这个信息做出相应的优化
  * 比如，C++ 中的虚方法，对于一个虚方法调用，尽管有很多目标方法，但在实际运行的时候可能只调用其中一个
  * 这个信息就可以被即时编译器利用，来规避虚方法调用的开销，从而达到更高的性能



![image-20220811133451727](https://s2.loli.net/2022/08/11/Z5GPw3lSs7LItn8.png)







![image-20220811133503541](https://s2.loli.net/2022/08/11/kHpCROIYSAG4T2a.png)



## 虚拟机视角下的基本类型

> 除 long 和 double 外，其他基本类型与引用类型在解释执行的方法栈帧中占用的大小是一致的，但是在堆中占用的大小确不同，在将 boolean byte char 以及 short 的值存入字段或者数组单元时，Java 虚拟机会进行掩码操作，在读取时，Java 虚拟机会将其扩展为 int



### 存储

需要明确一点： Java 语言规范 和 Java 虚拟机规范对基本类型数据有不同定义

例如 boolean类型：

*  Java 语言规范中，只有两个取值 true 和 false，但是这两个符号不能直接被虚拟机使用
* Java 虚拟机规范中，boolean 类型会被映射为整型值， true -> 1; false -> 0

因此，对于 Java 虚拟机来说，它看到的 boolean 类型早已经被映射为整数类型。将原本声明为 boolean 类型的局部变量，赋值为 0 和 1之外的整数，在虚拟机来看是合法的

![image-20220812121722234](https://s2.loli.net/2022/08/12/YQqhluFx5VvboXL.png)



> 在  Java 虚拟机规范中，**局部变量等价于一个数组**。并且可以用通过正整数来索引。除了 long、double 需要用两个数组单元来存储之外，**其他基本类型以及引用类型的值均占用一个数组单元**

也就是说，boolean、byte、char、short 这四种类型，虽然在 Java 语言规范中其大小和 Int 类型不同，但是在虚拟机栈上，占用的空间是一样的，和引用类型也是一样的，均为一个数组单元。

* 32 位 HotSpot 中，这些类型占用 4 个字节， 
* 64 位中占用 8 个字节



<u>另外需要注意一点，这种情况仅仅适用于**局部变量**，对于堆中的字段或者数组元素，在堆上占用的空间和Java 语言规范中的定义是相吻合的！</u>

---



![image-20220812121805963](https://s2.loli.net/2022/08/12/oze6VpZFGJ4iMCw.png)

前面的例子中，我们将 Boolean 赋值 2，超出了值域， 同样的，在虚拟机栈中，由于这些类型都要占用一个数组单元， byte char short 类型的局部变量也都可以超出值域！

在 Java 中，**正无穷和负无穷都有确切的值**，内存中分别等于 Ox 7F80 0000 和 OX FF80 0000

[Ox 7F80 0001,Ox 7FFF FFFF ]，[Ox FF80 0001,Ox FFFF FFFF ] 对应的都是 NaN，Not a Number



当我们将一个 int 类型的值，存储到这些类型的字段或者数组，相当于做了一个隐式的掩码

也就是说，从虚拟机栈到堆中，需要进行掩码操作，确保值域正确

boolean 和 boolean 数组比较特殊，在 HotSpot 中，boolean 字段占用一个字节，而 boolean 数组直接用 byte 数组来实现。

为了保证堆中的 boolean 值是合法的，HotSpot  会进行显示的掩码操作，也就是说，只取最后一位的值存入 boolean 字段或数组中



### 加载

Java 虚拟机的算数运算几乎全部依赖于 **操作数栈**，也就是说，我们需要将堆中的 boolean byte char 以及 short 加载到操作数栈上，然后将值当作 int 类型计算

* 对于 boolean 和 char，伴随着零扩展
  * 加载 char 的时候，其值被复制到 int 的低二字节，高二字节用 0 填充
* byte 和 short ，伴随着符号扩展
  * 同样将值赋值到低二字节，如果short 最高位为0，那么高二用 0 填充，否则用 1



![image-20220812123750607](https://s2.loli.net/2022/08/12/564XZDOVF7afSty.png)

![image-20220812123816444](https://s2.loli.net/2022/08/12/zqCN7JA964xdyTQ.png)



## 类的加载

> 从 class 文件到内存中的类，需要经过 加载、链接、初始化三个步骤

Java 语言的类型可以分为两大类 ： **基本类型** 和 **引用类型**

* 基本类型： Java 虚拟机预先定义好的

* 引用类型：细分为 类、接口、数组类、泛型参数

  * 泛型参数会在编译过程中被擦除
  * 数组类是 Java 虚拟机直接生成的
  * 类 和 接口 存在对应字节流
  * 无论是直接生成的数组类还是加载的类， Java 虚拟机都会对其进行链接和初始化

  ---

  

### 类的加载 - 加载

* 双亲委派
* 懒加载： 五种情况



#### 类加载-初始化

加载过程，是查找字节流，并且据此创建类的过程。

一个 class 文件平时存在硬盘上，这些内容被 load 到内存上究竟发生了什么？

内存中实际上创建了两块内容：

* 一块内容就是实实在在二进制的东西，被放在内存里

* 于此同时生成了 class 类的对象（单例），帮我们解析好，这个对象指向了这块内容。

* 以后，通过我们自己写的对象访问 这个 class 类的对象，再访问到我们的内存中的 class 文件

* class 的对象是在方法区中



![image-20220811134520917](https://s2.loli.net/2022/08/11/ok61ZxGA9KJFMia.png)



#### 类加载器

![image-20220811134539946](https://s2.loli.net/2022/08/11/W3q9F7zuZjSYTp4.png)

类加载器负责装入类，搜索网络、jar\zip\文件夹\二进制数据\内存等指定位置的类资源

一个 java 程序运行，最少有三个类加载器实例，负责不同类的加载

* Bootstrap loader 核心类库加载器
  * C/C++ 实现，无对应 java 类
  * JRE_HOME/jre/lib 目录，或用户配置的目录
* Extension class loader 拓展类库加载器
  * 加载 JRE_HOME/jre/lib/ext 目录，JDK 扩展包，或用户配置的目录
* application class loader 用户应用程序加载器
  * AppClassLoader 类的实例，加载 java.class.path 指定的目录，用户应用程序 class-path 或者 java 命令运行是参数 -cp

#### 类加载过程 - 双亲委派



![image-20220811135546028](https://s2.loli.net/2022/08/11/lEWKGZ71NTjHLPk.png)



* 每个加载器都有自己的缓存
* 每个 classLoader 的父加载器 parent 是 **final 值**，无法更改



* 为了避免重复加载，由下到上逐级委托，由上到下逐级查找

首先**不会自己去尝试加载类**，而是把这个请求**委派给父加载器**去完成；

每一个层次的加载器都是如此，因此所有的类加载请求都会传给上层的启动类加载器

只有**当父加载器反馈自己无法完成该加载请求时**（该加载器的搜索范围中没有找到对应的类），子加载器才会尝试自己去加载

> 注意：类加载器之间不存在子类和父类的关系，“双亲”是翻译，可以理解为逻辑上定义的上下级关系

* 为什么使用双亲委派， java.long.String 类由自定义类加载器行不？

  主要是为了安全，防止自己实现的类覆盖掉核心类

  例如自己实现了 java.lang.String，在这个类加载的过程中如果不向上委托，那么在 custom classLoader 就会被加载进来，而 java 原有的实现就会被覆盖，出现安全问题

#### 自定义类加载器





![image-20220811142033876](https://s2.loli.net/2022/08/11/wE5uXfjBzFl7OQM.png)

![image-20220811142219995](https://s2.loli.net/2022/08/11/HK5VDcC8dxngrjw.png)



* 自定义 classLoader 的时候，需要重写 **findClass** 方法
* 读取文件内容，**转换为 class 类对象**，使用 defineClass(参数中的 0 和 length 标识了内存中的位置)

![image-20220811142636216](https://s2.loli.net/2022/08/11/prcKlD2tg1kaUmT.png)

* MSBClassLoader 是我们自定义的，Load 指定目录下的 class 文件

![image-20220811143122297](https://s2.loli.net/2022/08/11/FceWrVAyT1l6wqj.png)



综上所述，我们再梳理一下类加载的流程 (loadClass 方法 )：

* 首先调用，findLoadedClass 方法，如果已经 Load 直接用
* 如果 findLoadedClass 返回空，证明自己没 Load 过，那么调用 parent.loadClass 方法，交给父加载器去加载，如果 parent 为空，交给 Bootstrap 加载器 
* 如果找到最顶层，还是没找到，证明这个类没有被 Load 过，那么就需要加载，调用 findClass 方法
* 在 findClass 方法中，从顶层开始（因为 findClass 方法会递归到最顶层），调用 defineClass 读取对应位置下的 class 文件，如果找不到就会抛异常，交给子加载器加载，直到找到为止。



#### 编译器

![image-20220811145919439](https://s2.loli.net/2022/08/11/r2qjESMCkDxWYe7.png)



#### 懒加载

![image-20220811150211413](https://s2.loli.net/2022/08/11/Mi5GuU3jLWhxHoS.png)

![image-20220811152349317](https://s2.loli.net/2022/08/11/fLdEbQv2wqC3FDJ.png)



### 类的加载 - 链接

链接，是将创建成的类合并到 Java 虚拟机中，使之能够执行的过程。分为 验证、准备和解析三个阶段

* 验证：确保被加载的类满足 Java 虚拟机的约束条件
* 准备：初始化加载类的 **静态字段** ，分配内存，赋初值。还会构造根其他类层次相关数据结构，比如说用来实现虚方法动态绑定**方法表**
  * 在 class 文件被加载到 Java 虚拟机之前，这个类无法知道 其他类及其方法、字段对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员，**Java 编译器会创建一个符号引用**，在运行阶段，这个符号引用一般能无歧义定位到具体目标
* 解析：符号引用解析为实际引用。
  * 如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么将**触发这个类的加载，但未必触发链接及初始化**，细节！



---



### 类的加载 - 初始化

> 在 Java 代码中，如果要初始化一个静态字段，可以在声明的时候赋初值，也可以在静态代码块中赋值。
>
> **如果直接赋值的静态字段被 final 修饰，并且它的类型是基本类型或字符串，那么该字段会被 Java 编译器标记未 常量值，常量值的初始化直接由 Java 虚拟机完成。**
>
> **除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器放置在同一个方法中，命名为 <clinit>**

初始化的过程，就是为标记为常量的字段赋值，同时执行 <clinit> 方法



## 关于 Object o = new Object()

单例模式：某个类的对象在内存中保证只有一份。构造方法私有化，类内部返回自己创建的类对象

![image-20220811091930663](https://s2.loli.net/2022/08/11/AewqWDvRbOKCrPF.png)

![image-20220811091908030](https://s2.loli.net/2022/08/11/Xm8UHxsgQv2JuBq.png)

---



* 请解释一下对象的创建过程？（半初始化状态）
* 加问 DCL 与 volatile 问题？（指令重排）
* 对象在内存中的存储布局
* 对象头具体包括什么
* 对象怎么定位
* 对象怎么分配？（栈上-线程本地-Eden-Old）
* Object o = new Object（） 在内存中占用多少字节
* 为什么 hotspot 不使用 c++ 对象来代表 java 对象
* Class 对象是在堆还是在方法区

---

### 对象的创建方式

Java 中，新建对象共有五种方式

* new 关键字
* 反射
* Object.clone()
* 反序列化
* Unsafe.allocateInstance

> 其中 ，
>
> * Object.clone 和 反序列化 直接复制已有的数据，来初始化新建对象的实例字段
>
> * Unsafe.allocateInstance 没有初始化实例字段
>
> * new 关键字(invokespecial) 和 反射机制，调用构造器来初始化实例字段
> * 当我们调用一个构造器的时候，它将优先调用父类构造器，直到 Object



### 对象的创建过程



![image-20220811091949976](https://s2.loli.net/2022/08/11/BQI582THJtCZkvu.png)



* new 指令 ，allocate，申请一块内存，**把一块确定的大小的内存从java堆中划分出来**，这个时候 m = 0
  *  a、指针碰撞（Bump the Pointer）：假如java堆中的内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配的内存就仅仅是把那个指针向空闲空间那边挪动一段与对象的大小相等的距离。
  *  b、空闲列表（Free List）: 假如java虚拟机不是规整的，<u>已使用的内存和空闲的内存相互交错</u>，虚拟机就必须维护一个列表，记录上那些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新表上的实例。选择哪种分配方式由java堆是否规整决定，而java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。
  *  设置对象头
* invokespecial ，执行构造方法
* astore ： 我们的引用 t 和 m **建立关联**



* 那么**new 指令后，为什么一定要dup操作呢?**
* 因为java代码的new操作编译为[虚拟机](https://so.csdn.net/so/search?q=虚拟机&spm=1001.2101.3001.7020)指令后，虚拟机指令new在堆上分配了内存并在栈顶压入了指向这段内存的地址供任何下面的操作来调用，但是在这个操作数被程序员能访问的操作之前，虚拟机自己肯定要调用对象的 <init> 方法，也就是如果程序员做一个 Type a = new Type(); 其实要连续两次对栈顶的操作数进行操作。**其中一次是虚拟机内部自动调用的，另一次才是程序员的访问，例如给变量赋值，抛出异常等**。



###  DCL 与 volatile 

DCL： Double Check Lock 双重检查

```
new # 这一步执行完，对象内存已经 new 出来，但是还没有初始化（默认值），这种状态成为半初始化
dup
invokespecial
astore_1
return
```

![image-20220811091832176](https://s2.loli.net/2022/08/11/lQYcoq7jCzGRMUr.png)



在创建对象的过程中发生了指令重排，还没有执行构造方法就建立了关联（**单线程下这样做是没有影响的**）

这时候又进来了一个线程，判断 instance 不等于空，将这个对象拿走了

即，半初始化状态

因此，必须要加 volatile，对这个对象的读写不可以重排序



### 对象在内存中的存储布局

普通对象包括四个部分

* 标记字段      (markword) ： 保存 Java 虚拟机有关该对象的运行数据，哈希码、GC 信息以及锁信息
* 类型指针  (class pointer) ： 指向该对象的类
* 实例数据  (instance data) 
* 对齐            (padding)

数组对象，则在此基础上，多了 4 个字节用来保存 数组长度



*<u>下图有问题，红色的对象头方框，内容应该是 标记字段</u>*

![img](https://s2.loli.net/2022/08/10/DQHTNpBvghwm7Y4.png)



#### 压缩指针来源

在 64 位的 Java 虚拟机中，**<u>对象头的标记字段占 8 个字节（64位），类型指针占 8 个字节</u>**。也就是说，<u>每个 Java 对象在内存中的 额外开销 就是 16 个字节</u>。以 Integer 类为例，仅有一个 int 类型的私有字段，占 4 个字节，但是 额外开销就是 16 个字节，是非常不划算的，这也是 java 引入基本类型的原因。

> **为了尽量减少对象内存的使用量， 64 位的 Java 虚拟机引入了压缩指针的概念，将原本 8 个字节 64 位 的类型指针，压缩成 4 个字节 32 位。**

这样一来，<u>对象头的大小就从 16 个字节压缩成了 12 个字节</u>。当然，压缩指针不仅可以作用域对象头的类型指针，还可以作用于引用类型的字段，以及引用类型的数组。



#### 压缩指针原理

![image-20220813231647836](https://s2.loli.net/2022/08/13/caoVdHUhAEQJ6ZN.png)

#### 内存对齐，padding

因为压缩指针的存在，我们需要 **内存对齐**

> * 默认情况下， **Java 虚拟机中对象的起始地址需要对齐到 8 的倍数**。如果一个对象大小不满 8N 个字节，空白的部分就被浪费掉了，我们将其称之为 对象间的填充，也就是图中的 padding
> * 默认情况下， Java 虚拟机中的 32 位压缩指针可以寻址到 2 的 35 次方个字节，也就是 32 GB，超过这个大小就会关闭压缩指针

另外需要注意的是，内**存对齐不仅存在于对象与对象之间，也存在于对象中的字段之间**。比如说， Java 虚拟机要求 long 字段、double 字段、以及非压缩指针状态下的引用字段地址为 8 的倍数。

字段内存对齐的其中一个原因，是**让字段只出现在同一 CPU 缓存行中**。

如果字段不是对齐的，那么就有可能出现跨缓存行字段，也就是说，读取该字段可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。降低了程序效率。



#### 字段重排列

> Java 虚拟机重新分配字段的先后顺序，达到内存对齐的目的

![image-20220813232905801](https://s2.loli.net/2022/08/13/PcK2r47n8jLMgCU.png)

![image-20220813232955826](https://s2.loli.net/2022/08/13/uxpTQY6w3CvaKeq.png)

![image-20220813233015778](https://s2.loli.net/2022/08/13/qDSvg4GmxeKkMs2.png)









#### 虚共享

> Java 8 引入了一个新的注释, @Contended，用来解决对象字段之间的虚共享

* 什么是虚共享？
  * 假设两个线程分别访问 **同一对象 的 不同 volatile 字段**，逻辑上它们并没有共享内容，因此不需要同步
  * 然而，如果这两个字段恰好在同一个缓存行中，那么对这些字段的写操作会导致缓存行的写回，也就造成了实质上的共享
  * 因此， **Java 虚拟机会让 @Contented 字段处于独立的缓存行中**，大量的空间因此浪费



### 对象头具体包括什么

对象头包括 markword + class pointer

### **Object o = new Object() 在内存中占了多少个字节**

>  **Object 16字节**

jvm 本身默认开启了 class pointer 的压缩，于是由如下过程。

markword + class pointer + instance data + padding

对象头（markword + class pointer）： 12字节

*  markword： 8 字节
*  class pointer ： 4 字节 (默认经过压缩)
*  instance data: 空的（object 没有成员变量）
*  padding： 补到 8 的倍数， 4 字节

padding 当整体字节数不能被 8 整除的时候，进行填补

![image-20220812142204612](https://s2.loli.net/2022/08/12/EUVocWmls1RQ97A.png)

如下所示

| OFFSET | SIZE | DESCRIPTION                                     |
| ------ | ---- | ----------------------------------------------- |
| 0      | 4    | object header (markword)                        |
| 4      | 4    | object header (markword)                        |
| 8      | 4    | object header (class pointer)                   |
| 12     | 4    | loss due to the next object alignment (padding) |

> 注意一个小坑，Object o 开启了一个引用， 20个字节
>
> 另外，如果 Jvm 不开启  class pointer 压缩，那么 class pointer 占用 **8** 个字节，加上 markword 的 8 个字节，总共也是 16 个



**如果添加成员变量呢？**

例如： User{

​	int id;

​	String name;

}

markword ：8 字节

class pointer:  4 字节

instance data:   8 字节    （integer 4 字节 + String 引用 4 字节）  

padding : 4 字节 (填充为 8 的倍数)

总共： 24 字节

---



### **对象的定位方式**

句柄和直接指针

* 直接指针，引用 t 指向堆中的实例数据，实例数据中包含指向类型数据的指针
  * 优点：效率高
  * 缺点：每经过一次 GC 复制，就需要跟着改变
* 句柄，引用 t 指向一组指针，包括实例数据和类型数据
  * 优点：方便 GC， GC 复制的时候，里面的值不需要变

![image-20220811213619455](https://s2.loli.net/2022/08/11/lY4dQVPKXESbaH3.png)

---



### **对象怎么分配**

![image-20220811215419259](https://s2.loli.net/2022/08/11/89aqMpJjV1AEhD5.png)

* 栈上分配
  * new 出来的对象**优先分配在栈上**，条件是 **大小较小** （JVM 调优的时候我们经常调整 -xss 参数，即栈帧大小，这样就允许有更多对象直接分配在栈上）且 **不存在逃逸** 且**支持标量替换**。
    * 直接分配在栈上的对象，会随着栈帧弹出自动销毁，**不需要 GC 介入**，因此效率很高
    * 不存在逃逸的意思是：只有当前栈帧使用到该对象，除此之外没有其他地方使用到这个对象


* 线程本地分配 TLAB
  * 如果不是很大，分配在线程本地缓冲区（Thread Loca Allocation Buffer，TLAB），Eden 区分配。每个线程都有自己额外的小小的空间，优先往自己的 TLAB 分配
    * 占用 eden，默认 1%
    * 多线程的时候不用竞争 eden 就可以申请空间，提高效率
    * 小对象
    * 经过一次 GC ，清除掉了，就被销毁
    * 如果没清除掉，从年轻代去 Survive 区，再经过垃圾回收，年龄够大区 Old，否则去另一个 Survive ，在此循环往复
* 如果不能分配在栈上，判断这个对象是不是很大，如果是，分配在 老年代，之后通过 GC 回收
* Eden 区

![image-20220812141124753](https://s2.loli.net/2022/08/12/c8LgTXAVCZBqFPt.png)

![image-20220812141203968](https://s2.loli.net/2022/08/12/gAa36lsEY4D1b9F.png)



---



### **为什么 hotspot 不使用 c++ 对象来代表 java 对象**

c++ 对象存在一个虚函数表，占用内存太大了



### **Class 对象是在堆还是在方法区**

方法区、永久代、元空间的区别是：

* 方法区是接口，剩下两个是实现类

  * jdk 1.7 之前，方法区的实现叫永久代

  * 1.8 开始，方法区的实现叫 元空间

instanceClassOOP 对象，是一个 C++ 对象，在方法区，指回到堆空间。

* **为什么扔在堆里，方便我们拿出来做反射用**

* 各种各样代理对象太多的时候，方法区会出现 OOM

![image-20220811215931586](https://s2.loli.net/2022/08/11/6bgKyd1NfG7JFCj.png)







## GC

### GC roots

* 线程栈变量
* 静态变量
* 常量池
* JNI 指针



- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象





![image-20220812085033832](https://s2.loli.net/2022/08/12/6yz9U7NvEqXmQMC.png)



### 垃圾收集算法

* 标记-清除 (Mark-Sweep) 算法：首先表示出所有要回收的对象，然后进行清除
  * 标记、清除过程效率有限，有**内存碎片化**问题，不适合特别大的堆；
  * 收集算法基本基于 标记-清除 的思路进行改进
* 复制(Copying)算法： 划分两块同等大小的区域，收集时将或者的对象复制到另一块区域
  * 拷贝过程中将对象顺序放置，就可以**避免内存碎片化**。**复制 + 预留内存，有一定的浪费**
* 标记-整理 (Mark-Compact)算法：类似于标记-清除，但为避免内存碎片化，它会**在清理过程中将对象移动**，以确保移动后的对象占用连续的空间
  * 效率很低，是这三种垃圾收集算法中效率最低的

![image-20220812085201165](https://s2.loli.net/2022/08/12/OHgK8yjRtz7aQrw.png)

![image-20220812085338343](https://s2.loli.net/2022/08/12/1FogBDpbaLmkr9q.png)

![image-20220812085425867](https://s2.loli.net/2022/08/12/QjnMAGe7F93YWc5.png)



### 常用垃圾回收器

* 随着内存大小的不断增长而改进

![image-20220812085628766](https://s2.loli.net/2022/08/12/fEuLUCkQdh3qj6Y.png)



* 内存 几兆 - 几十兆
  * 单线程 STW 垃圾回收，年轻代，老年代

![image-20220812090917282](https://s2.loli.net/2022/08/12/zoE2PLGq1A4X6Qp.png)

![image-20220812091143547](https://s2.loli.net/2022/08/12/3CqvfzjVoWPImlt.png)

> stop-the-world: 单线程下，垃圾清除会**暂停用户线程**，不能一边清理垃圾一边产生垃圾。



* 几十兆 - 上百兆 1G
  * paraell 并行
  * Paraell Scaveng + Paraell Old ： 简称 PS + PO， 1.8 默认



* 几十 G
  * Concurrent GC

Concurrent 不需要 STW，GC 线程 和 业务线程并发

![image-20220812092322436](https://s2.loli.net/2022/08/12/rEW3pf5JU1yGMgS.png)

### 常见垃圾回收器组合

![image-20220812091721611](https://s2.loli.net/2022/08/12/tDsiFkmAf5oV2nd.png)





#### CMS

* 工作在老年代
* 存在的问题
  * Memory Fragmentation 内存碎片化
    * Mark sweep 本身就会导致内存碎片化。 Mark sweep 这种垃圾收集算法本身是建立在小内存的基础上，却被应用在现在的大内存。

  * Floating Garbage 浮动垃圾
    * 当老年代中存在很多内存碎片，年轻代进来就找不到空间了。在这种情况下，Serial Old 就会被请出来做标记压缩， stop the worl
    * **PromotionFaild**，就是上述情况

  * 解决方案
    * 降低 CMS 触发阈值
    * 保证老年代有足够空间

  * 案例
    * 硬件升级系统反而卡顿
    * 线程池不当运用产生 OOM


![image-20220812144647367](https://s2.loli.net/2022/08/12/ecu3DKWPaN9wi2f.png)



![image-20220812092535610](https://s2.loli.net/2022/08/12/njPx3QKbWR6rhOM.png)

![image-20220812092836500](https://s2.loli.net/2022/08/12/aWC5xrbBdcQYZXA.png)

##### 初始标记

标记 GC root

##### 并发标记

###### CMS 三色标记算法

##### 重新标记

##### 并发清理

![image-20220812143617654](https://s2.loli.net/2022/08/12/78aHUtfwIAkmdp3.png)



---



#### ParNew

![image-20220812092714019](https://s2.loli.net/2022/08/12/SKLfMO3VCPrDIXc.png)



#### G1

物理上不分代，逻辑上分代





![image-20220813150208341](https://s2.loli.net/2022/08/13/TPydWOh3pQ2xNLw.png)





### JVM 内存分代模型

> 除 Epsilon ZGC Shenandoah 之外的 GC 都是使用逻辑分代模型
>
> G1 是逻辑分代，物理不分代
>
> 除此之外，不仅逻辑分代，而且物理分代

* 新生代 + 老年代 + 永久代（1.7） Perm Generation / 元数据区(1.8) MetaSpace
  * 永久代 元数据 - Class
  * 永久代必须指定大小限制，元数据可以设置，也可以不设置，无上限（受限于物理内存）
  * **字符串常量 1.7 - 永久代， 1.8 - 堆**
  * MethondArea 逻辑概念 - 永久代 元数据
* 新生代 = Eden + Survivor * 2
  * YGC 回收之后，大多数的对象会被回收，活着的进入 s0
  * 再次 YGC，活着的对象 eden + s0 -> s1
  * 再次 YGC， eden + s1 -> s0
  * 年龄足够 -> 老年代 (markword 中使用 4 位 标记这个状态，因此最大 16 ，大部分 15 ，cms 6)
  * s 区装不下 -> 老年代
* 老年代
  * 顽固分子
  * 老年代满了 应用 Full GC

![image-20220812141554236](https://s2.loli.net/2022/08/12/P1oZUK3XscJOtSm.png)



### 分代收集

根据对象的存活周期，将内存划分为几个区域，不同区域采用合适的垃圾收集算法

新对象会被分到 Eden，如果超过某个值，设置大对象直接进入老年代的阈值

新生代采用复制算法，老年代采用标记整理算法

* 年轻代 GC 回收被成为 miner GC 或者 YGC，一般来说能回收掉 90% 对象
  * 因此就没有必要平分两半，一般比例 8：1
  * 存活下来的区 survivor
  * 再下一次 GC 的时候，同时扫描 eden 和 survivor，放入 survivor 2，将 eden 和 survivor1 同时清空
* 老年代满了，就会触发 Full GC

![image-20220812085747135](https://s2.loli.net/2022/08/12/S1clgCszTaK3Qev.png)



## 调优前的基础概念

* 吞吐量： 用户代码时间 / （用户代码执行时间 + 垃圾回收时间）
* 响应时间 ： STW 越短，响应时间越好

科学计算，吞吐量。数据挖掘，thrput，吞吐量优先的一般 ： PS + PO

响应时间： 网站 GUI API （1.8 G1）

 CMS + PN 吞吐量 高于 G1 



什么是调优？

* 根据需求进行 JVM 规划和预调优
* 优化运行 JVM 运行环境
* 解决 JVM 运行过程中出现的各种问题

































































