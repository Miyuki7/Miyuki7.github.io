## 1.链表简介及分类

### 1.简介

* 如果我们申请一个 100MB 大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败。而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用，所以如果我们申请的是 100MB 大小的链表，根本不会有问题。

![img](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgd5d5bee4be28326ba3c28373808a62cd.jpg)

### 2.单链表

* 链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的“结点”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。我们把这个记录下个结点地址的指针叫作后继指针 next。![img](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgb93e7ade9bb927baad1348d9a806ddeb.jpg)

  其中有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。我们习惯性地把第一个结点叫作头结点，把最后一个结点叫作尾结点。其中，==头结点用来记录链表的基地址==。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是==指向一个空地址 NULL==，表示这是链表上最后一个结点。

* 链表插入删除：

  在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的，对应的时间复杂度是O(1)。![img](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-img452e943788bdeea462d364389bd08a17.jpg)

* 缺点：

  链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点，需要 O(n) 的时间复杂度。

### 3.循环链表

* 循环链表是一种特殊的单链表。它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。![img](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-img86cb7dc331ea958b0a108b911f38d155.jpg)

* 优点

  循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如[约瑟夫问题](https://zh.wikipedia.org/wiki/约瑟夫斯问题)。

### 4.双向链表

* 单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。![img](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgcbc8ab20276e2f9312030c313a9ef70b.jpg)

* **优点**

  双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单高效。

  * **插入和删除**

    1. **删除结点中“值等于某个给定值”的结点。**

       不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再将其删除。

       单纯的删除操作时间复杂度是 O(1)，==但遍历查找的时间是主要的耗时点，对应的时间复杂度为 O(n)。==根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的==总时间复杂度为 O(n)==。

    2. **删除给定指针指向的结点。(优势)**

       我们已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到 p->next=q，说明 p 是 q 的前驱结点。对于双向链表来说，这种情况就比较有优势了。因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度内就搞定了！

  * **按值查询效率高**

    对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平==均只需要查找一半的数据==。

  * **应用广泛**

    双向链表尽管比较费内存，但还是比单链表的应用更加广泛。Java 语言， LinkedHashMap 的实现原理就用到了双向链表这种数据结构。
    
    双向链表采用了空间换时间的设计思想。当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。

### 5.双向循环链表

![img](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgd1665043b283ecdf79b157cfc9e5ed91.jpg)

-----



## 2.链表、数组对比

![img](https://static001.geekbang.org/resource/image/4f/68/4f63e92598ec2551069a0eef69db7168.jpg)

数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。

数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。

如果代码对内存的使用非常苛刻，那数组就更适合。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。

----

## 3.写好链表代码

### 1.理解指针或引用的含义

1. 含义：将某个变量（对象）赋值给指针（引用），实际上就是就是将这个变量（对象）的地址赋值给指针（引用）。
2. 示例：
   p—>next = q; 表示p节点的后继指针存储了q节点的内存地址。
   p—>next = p—>next—>next; 表示p节点的后继指针存储了p节点的下下个节点的内存地址。

### 2.警惕指针丢失和内存泄漏（单链表）

1. 插入节点
   在节点a和节点b之间插入节点x，b是a的下一节点，，p指针指向节点a，则造成指针丢失和内存泄漏的代码：

   ```
   p—>next = x;x—>next = p—>next
   ```

   ;显然这会导致x节点的后继指针指向自身。
   正确的写法是2句代码交换顺序，即：

   ```
   x—>next = p—>next; 
   
   p—>next = x;
   ```

   

2. 删除节点
   在节点a和节点b之间删除节点b，b是a的下一节点，p指针指向节点a：

   ```
   p—>next = p—>next—>next;
   ```

   

### 3.利用“哨兵”简化实现难度

1. 什么是“哨兵”？
   链表中的“哨兵”节点是解决边界问题的，不参与业务逻辑。如果我们引入“哨兵”节点，则不管链表是否为空，head指针都会指向这个“哨兵”节点。我们把这种有“哨兵”节点的链表称为带头链表，相反，没有“哨兵”节点的链表就称为不带头链表。

2. 未引入“哨兵”的情况
   如果在p节点后插入一个节点，只需2行代码即可搞定：

   ```
   new_node—>next = p—>next;
   p—>next = new_node;
   ```

   但，若向空链表中插入一个节点，则代码如下：
   if(head == null){
   head = new_node;
   }
   如果要删除节点p的后继节点，只需1行代码即可搞定：

   ```text
   p—>next = p—>next—>next;
   ```

   但，若是删除链表的最有一个节点（链表中只剩下这个节点），则代码如下：

   ``` text
   if(head—>next == null){
   head = null;
   }
   ```


   从上面的情况可以看出，针对链表的插入、删除操作，需要对插入第一个节点和删除最后一个节点的情况进行特殊处理。这样代码就会显得很繁琐，所以引入“哨兵”节点来解决这个问题。

3. 引入“哨兵”的情况
   “哨兵”节点不存储数据，无论链表是否为空，head指针都会指向它，作为链表的头结点始终存在。这样，插入第一个节点和插入其他节点，删除最后一个节点和删除其他节点都可以统一为相同的代码实现逻辑了。

### 4.重点留意边界条件处理

经常用来检查链表是否正确的边界4个边界条件：
1. 如果链表为空时，代码是否能正常工作？
2.如果链表只包含一个节点时，代码是否能正常工作？
3.如果链表只包含两个节点时，代码是否能正常工作？
4. 代码逻辑在处理头尾节点时是否能正常工作？

### 5.举例画图，辅助思考

核心思想：释放脑容量，留更多的给逻辑思考，这样就会感觉到思路清晰很多。

### 6.链表相关代码

1. 实现一个链表并且判断一个字符串是否是回文字符串。

   [github](https://github.com/wangzheng0822/algo/blob/master/java/06_linkedlist/SinglyLinkedList.java)

2.  

   5个常见的链表操作：
   1.单链表反转
   2.链表中环的检测
   3.两个有序链表合并
   4.删除链表倒数第n个节点
   5.求链表的中间节点

   ​     [源代码](https://github.com/Miyuki7/algo/blob/master/java/07_linkedlist/LinkedListAlgo.java)

3. 基于单链表实现LRU算法

   [github](https://github.com/wangzheng0822/algo/blob/master/java/06_linkedlist/LRUBaseLinkedList.java)