

## [704. 二分查找](https://leetcode.cn/problems/binary-search/)

![image-20221110212844197](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221110212844197.png)

注意点

* 位运算的优先级很高，一定要加括号，不然就先计算left>>1了

* 搞清楚终止条件

  * left = 0， right= length - 1的话终止条件就是left <= right，因为right的值式可以取到的，还有就是right = mid - 1，始终保持right可以取到

    ``` java
    public int search(int[] nums, int target) {
            int left = 0, right = nums.length - 1;
            while (left <= right) {
                int mid = left + ((right - left) >> 1);
                if (nums[mid] == target) {
                    return mid;
                }
                if (nums[mid] < target) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            return -1;
        }
    ```

  * left = 0, right = length的话终止条件就是left < right，因为一旦right是取不到的，所以一旦left == right肯定就要退出了。要保证right=mid始终不能取到mid[right]。

    ``` java
    public int search(int[] nums, int target) {
            int left = 0, right = nums.length;
            while (left < right) {
                int mid = left + ((right - left) >> 1);
                if (nums[mid] == target) {
                    return mid;
                }
                if (nums[mid] < target) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            return -1;
        }
    ```

## [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

![image-20221110214342421](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221110214342421.png)

* 解法一：left = 0， right = length - 1，其实找不到的话返回left就行了，因为循环的最后一次条件就是left == right 肯定会落到nums[mid]上此时right == left==mid，如果nums[mid] < target，那么left = mid + 1，这个left就是要返回的；如果nums[mid] > target，那么就返回mid就好，而mid ==left，所以返回left。

  ``` java
  public int searchInsert(int[] nums, int target) {
          int left = 0, right = nums.length - 1;
          while (left <= right) {
              int mid = left + ((right - left) >> 1);
              if (nums[mid] == target) {
                  return mid;
              } else if (nums[mid] < target) {
                  left = mid + 1;
              } else {
                  right = mid - 1;
              }
          }
          return left;
      }
  ```

* 解法二：left = 0, right = length，有了解法一的理解，这个就好理解了，在最后一次循环中 left == mid < right 并且left + 1 = right，如果nums[mid] < target，那么left就变为mid + 1，此时left == right；如果nums[mid] > target，那么right = mid，同时right == mid == left了呗，所以返回left还是right都可以。

  ``` java
  public int searchInsert(int[] nums, int target) {
          int left = 0, right = nums.length;
          while (left < right) {
              int mid = left + ((right - left) >> 1);
              if (nums[mid] == target) {
                  return mid;
              } else if (nums[mid] < target) {
                  left = mid + 1;
              } else {
                  right = mid;
              }
          }
          return right;//return left;
      }
  ```

  