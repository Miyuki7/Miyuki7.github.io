## [704. 二分查找](https://leetcode.cn/problems/binary-search/)

![image-20221110212844197](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221110212844197.png)

注意点

* 位运算的优先级很高，一定要加括号，不然就先计算left>>1了

* 搞清楚终止条件

  * left = 0， right= length - 1的话终止条件就是left <= right，因为right的值式可以取到的，还有就是right = mid - 1，始终保持right可以取到

    ``` java
    public int search(int[] nums, int target) {
            int left = 0, right = nums.length - 1;
            while (left <= right) {
                int mid = left + ((right - left) >> 1);
                if (nums[mid] == target) {
                    return mid;
                }
                if (nums[mid] < target) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            return -1;
        }
    ```

  * left = 0, right = length的话终止条件就是left < right，因为一旦right是取不到的，所以一旦left == right肯定就要退出了。要保证right=mid始终不能取到mid[right]。

    ``` java
    public int search(int[] nums, int target) {
            int left = 0, right = nums.length;
            while (left < right) {
                int mid = left + ((right - left) >> 1);
                if (nums[mid] == target) {
                    return mid;
                }
                if (nums[mid] < target) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            return -1;
        }
    ```

## [878. 第 N 个神奇数字](https://leetcode.cn/problems/nth-magical-number/)(hard)

![image-20221122204905745](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221122204905745.png)

思路：第一眼可以用双指针（a,2a,3a...  b,2b,3b... 这样双指针往后走）但是看数据量o（n）是过不了的，那么就o（logn）用上二分

二分下限肯定是0，上限可以定成Math.min(a, b) * n，那么什么算满足条件，什么不算呢，可以统计在mid的左边的两个数字的倍数的个数是否满足n个，可以利用容斥定理，如下图，求出真正的mid左边的个数。

![image-20221122205313641](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221122205313641.png)

最大公约数的计算方法gcd（a， b）：

* 辗转相除法

  ``` java
  求最大公约数 辗转相除法(欧几里德算法) 例如，求（319，377）： ∵ 319÷377=0（余319）
       * ∴（319，377）=（377，319）； ∵ 377÷319=1（余58） ∴（377，319）=（319，58）； ∵
       * 319÷58=5（余29） ∴ （319，58）=（58，29）； ∵ 58÷29=2（余0） ∴ （58，29）= 29； ∴
       * （319，377）=29。 可以写成右边的格式。
       * 用辗转相除法求几个数的最大公约数，可以先求出其中任意两个数的最大公约数，再求这个最大公约数与第三个数的最大公约数，依次求下去，直到最后一个数为止。
       * 最后所得的那个最大公约数，就是所有这些数的最大公约数。
  private int gcd(int a, int b) {
          return b == 0 ? a : gcd(b, a % b);
      }
  ```

最小公倍数lcm（a， b）：利用最小公倍数与最大公约数的关系 lcm(a,b) = a * b / gcd(a,b)

**题解**

``` java
private static final long MOD = (long) 1e9 + 7;

    public int nthMagicalNumber(int n, int a, int b) {
        long left = 0;
        //记得用long，不用long有一半的用例都过不了
        long right = (long)Math.max(a, b) * n;
        long lcm = a * b / gcd(a, b);
        while (left < right) {
            long mid = left + ((right - left) / 2);
            if (mid / a + mid / b - mid / lcm < n){
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        //return (int)(right % MOD)也对，最后left == right
        return (int) (left % MOD);
    }

    private static int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
```

