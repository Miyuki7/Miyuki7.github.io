## [1704. 判断字符串的两半是否相似](https://leetcode.cn/problems/determine-if-string-halves-are-alike/)

![image-20221111112305688](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221111112305688.png)

将aeiouAEIOU存入到set中，看具体代码很灵性，然后从前往后遍历一遍，i<length /2时遇到元音字母cnt++，在后半段cnt--。

``` java
public boolean halvesAreAlike(String s) {
        Set<Character> set = new HashSet<>();
        for (char c : "aeiouAEIOU".toCharArray()) set.add(c);
        int cnt = 0;
        for (int i = 0; i < s.length(); i++) {
            if (!set.contains(s.charAt(i))) {
                continue;
            }
            cnt += i < s.length() / 2 ? 1 : -1;
        }
        return cnt == 0;
    }
```

## [791. 自定义字符串排序](https://leetcode.cn/problems/custom-sort-string/)

![image-20221113202833738](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221113202833738.png)

解法一思路：因为s和order都是只有小写字母，所以开辟一个大小为26的数组，把s中的字符存进去，很重要的一点是order中出现的字母必须有序，其他的乱序就行，所以优先按照order中的顺序排一波，剩下的随便排就行。

``` java
public String customSortString(String order, String s) {
        int[] sArr = new int[26];
        StringBuilder res = new StringBuilder();
        for (char ch : s.toCharArray()) {
            sArr[ch - 'a']++;
        }
        for (char ch : order.toCharArray()) {
            while (sArr[ch - 'a']-- > 0) {
                res.append(ch);
            }
        }
        for (char ch : s.toCharArray()) {
            while (sArr[ch - 'a']-- > 0) {
                res.append(ch);
            }
        }       
        return res.toString();
    }
```

* 时间复杂度：o（n + m）n、m分别为两个字符串的长度
* 空间复杂度：o（26）常数复杂度

解法二：利用Arrays.sort方法实现自定义排序规则，在order中越靠前的权重值越低，然后在Arrays.sort中从小排就行，有一个细节是必须要用**Character**[]才行，用char数组中的值在lambda表达式中会出错。

``` java
public String customSortString(String order, String s) {
        int[] val = new int[26];
        for (int i = 0; i < order.length(); i++) {
            val[order.charAt(i) - 'a'] = i + 1;
        }
        Character[] arr = new Character[s.length()];
        for (int i = 0; i < s.length(); ++i) {
            arr[i] = s.charAt(i);
        }
        Arrays.sort(arr, (c0, c1) -> val[c0 - 'a'] - val[c1 - 'a']);
        StringBuilder res = new StringBuilder();
        for (int i = 0; i < arr.length; i++) {
            res.append(arr[i]);
        }
        return res.toString();
    }
```

