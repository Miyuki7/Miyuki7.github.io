![image-20221123162502748](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221123162502748.png)

## 冒泡排序

①基础

![image-20221123164620210](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221123164620210.png)

``` java
static void bubbleSort1(int[] arr) {
        //比较的结束位置，第一次循环结束位置就是arr中的最后一个元素
        for (int end = arr.length - 1; end > 0; end--) {
            //每一轮比较从 0 到 end
            for (int begin = 1; begin <= end; begin++) {
                if (arr[begin] < arr[begin - 1]) {
                    swap(arr, begin - 1, begin);
                }
            }
        }
    }
    static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
```

②进阶一

![image-20221123175540345](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221123175540345.png)

在每一轮开始之前都搞一个布尔变量，记录这一轮次是否发生交换，没发生交换就提前退出。

缺点：在数据乱序很大的时候效率会降低，因为相比第一种没有优化的他还多了3个额外的语句。

``` java
static void bubbleSort2(int[] arr) {
        for (int end = arr.length - 1; end > 0; end--) {
            //每一轮开始时候都设置一个标志
            boolean sorted = true;
            for (int begin = 1; begin <= end; begin++) {
                if (arr[begin] < arr[begin - 1]) {
                    sorted = false;
                    swap(arr, begin - 1, begin);
                }
            }
            if (sorted) break;
        }
    }
```

③进阶二（终极版）

![image-20221123175852425](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221123175852425.png)

``` java
//endIndex代表发生交换的最后一个元素下标
    //例如：321456  第一趟排序结束变成213456，这个endIndex就是2，并且从下表2开始都有序了
    //下标3以及之后的元素都没有发生交换，所以可以将end直接跳转到endIndex-1，在for循环里有end--，所以end = endIndex后跳到下一层循环
    //里面end会自动减一（end--这个条件）
    static void bubbleSort3(int[] arr) {
        for (int end = arr.length - 1; end > 0; end--) {
            // endIndex可以设置为任意小于等于1的数
            //数据一开始就有序的话，在下面会将end赋值为1，接着外层循环中end--就不满足end>0就退出了
            int endIndex = 1;
            for (int begin = 1; begin <= end; begin++) {
                if (arr[begin - 1] > arr[begin]) {
                    swap(arr, begin - 1, begin);
                    endIndex = begin;
                }
            }
            end = endIndex;
        }
    }
```

稳定、原地

![image-20221123190414419](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221123190414419.png)

![image-20221123190506267](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221123190506267.png)

## 选择排序

![image-20221123191612708](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221123191612708.png)

**优于冒泡排序，冒泡排序每次都要交换，一交换就是三行代码，选择排序，只在每趟排序的最后交换**

``` java
//每次选取最大的放到后面有序数列的最钱买你
    public static void selectionSort(int[] arr) {
        for (int end = arr.length - 1; end > 0; end--) {
            int maxIndex = 0;
            for (int begin = 1; begin <= end; begin++) {
                //为了保证稳定性，需要用<=
                if (arr[maxIndex] <= arr[begin]) {
                    maxIndex = begin;
                }
            }
            swap(arr, maxIndex, end);
        }
    }

    //每次选取最小的放到前面有序数列的最后面
    public static void selectionSort2(int[] arr) {
        for (int end = 0; end < arr.length - 1; end++) {
            int minIndex = end;
            for (int right = end + 1; right < arr.length; right++) {
                if (arr[minIndex] > arr[right]) {
                    minIndex = right;
                }
            }
            swap(arr, end, minIndex);
        }
    }
```



## 堆排序

![image-20221123195858990](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221123195858990.png)

时间复杂度：建堆o（n），堆排序nlongn，所以时间复杂度是nlongn

![image-20221123203418389](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221123203418389.png)

## 快速排序

### 思路：

1. 确定分界点：q[l]或q[r]或q[(l + r) / 2]
2. 调整范围，比分界点小的都在左边，比分界点大的都在右边
3. 递归处理左右两部分

