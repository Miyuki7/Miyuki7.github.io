##  链表算法题

###  114.二叉树展开为链表（重点）

![image-20221108093901481](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221108093901481.png)

* 第一种解法：利用变式的前序遍历先把右节点保存到栈，再把左节点存到栈中，这样可以留存右节点，防止丢失。

![image-20221108094136903](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221108094136903.png)

* 第二种解法：

1. 将原来的右子树接到左子树的最右边节点

2. 将左子树插入到右子树的地方（第一二步的作用就是不破坏原来二叉树的右子树结构，因为你一直要改变root.right的，所以先将右子树完整的挪到左子树的最右节点）

3. 考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null

   ![image-20221108103255846](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221108103255846.png)

* 第三种：递归式的前序遍历（挺好理解的，但空间复杂度变高了有栈）

  ![image-20221108110901048](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221108110901048.png)

* 第四种（前序是中-左-右，，下面这种遍历方式是右-左-中，正好相反，反向生成就好了，避免了右指针的丢失）

  ![image-20221108112121493](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221108112121493.png)

  迭代法，模仿后序遍历的迭代方法

  ![image-20221108112532630](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221108112532630.png)

![image-20221108111857772](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221108111857772.png)

看这两个题解，评论里面还有很多解法。