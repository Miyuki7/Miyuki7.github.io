##  1.数组如何实现随机访问

1.  数组是一种线性数据结构，用连续的存储空间存储相同类型数据

2. 
   1. 线性表：数组、链表、队列、栈 （线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构）

![img](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgb6b71ec46935130dff5c4b62cf273477.jpg)

​		 	2. 非线性表：二叉树、堆、 图 等

![img](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-img6ebf42641b5f98f912d36f6bf86f6569.jpg)

3. 数组拥有连续的内存空间、相同的数据，所以数组可以随机访问，**但对数组进行删除插入，为了保证数组的连续性，就要做大量的数据 搬移工作**

4.  数组如何实现下标随机访问。

   ![img](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-img98df8e702b14096e7ee4a5141260cdc4.jpg)

   ```
   寻址公式：a[i]_address = base_address + i * data_type_size 其中 data_type_size 表示数组中每个元素的大小。 
   ```

   

5. 纠正数组和链表的错误认识。数组的查找操作时间复杂度并不是O(1)。即便是排好的数组，用二分查找，时间复杂度也是O（logn）。
   ==正确表述：数组支持随机访问，根据下标随机访问的时间复杂度为O（1）==

## 2.数组低效的插入和删除

###  1.插入

* **时间复杂度**：最好O(1) 最坏O(n) 平均O(n)

* **时间复杂度分析**：假设数组的长度为 n，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。

  如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+...n)/n=O(n)。

* **优化方法**：为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。

  现在需要将元素 x 插入到第 3 个位置。只需要将 c 放入到 a[5]，将 a[2]赋值为 x 即可。最后，数组中的元素如下： a，b，x，d，e，c。

  ![img](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-img3f70b4ad9069ec568a2caaddc231b7dc.jpg)

### 2. 删除

* **时间复杂度**：和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。
* **优化方法**：多次删除集中在一起，提高删除效率
  记录下已经被删除的数据，每次的删除操作并不是搬移数据，只是记录数据已经被删除，当数组没有更多的存储空间时，再触发一次真正的删除操作。即JVM标记清除垃圾回收算法。

## 3.数组相关问题

### 1.越界问题

* 一段c语言代码：

```c
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```

这段代码的运行结果并非是打印三行“hello word”，而是会无限打印“hello world”。

数组大小为 3，a[0]，a[1]，a[2]，而我们的代码因为书写错误，导致 for 循环的结束条件错写为了 i<=3 而非 i<3，所以当 i=3 时，数组 a[3]访问越界。我们知道，在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据我们前面讲的数组寻址公式，==a[3]也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。==

数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，==访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。==

* Java 本身就会做越界检查，如果出现类似问题，就会抛出 java.lang.ArrayIndexOutOfBoundsException。

### 2.容器与数组

>  相比于数组，java中的ArrayList、C++ STL 中的 vector封装了数组的很多操作，并支持动态扩容。（ArrayList 在每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小）但扩容时比较耗内存，因为涉及到内存申请和数据搬移，所以最好在创建 ArrayList 的时候事先指定数据大小。

数组适合的场景：

* Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，涉及装箱拆箱，有一定的性能损耗，如果特别关注性能，可以考虑数组。
*  若数据大小事先已知，并且涉及的数据操作非常简单，可以使用数组。
* 表示多维数组时，数组往往更加直观。比如 Object\[][] array；而用容器的话则需要这样定义：ArrayList<ArrayList<object> > array。
*  业务开发容器即可，底层开发，如网络框架，性能优化。选择数组。

### 3.为什么数组从0编号

1. 从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。如果用 a 来表示数组的首地址，a[0]就是偏移为 0 的位置，也就是首地址，a[k]就表示偏移 k 个 type_size 的位置，所以计算 a[k]的内存地址只需要用这个公式：

   ```
   a[k]_address = base_address + k * type_size
   ```

   如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为：

   ``` text
   
   a[k]_address = base_address + (k-1)*type_size
   ```

   对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。

2. 一定的历史原因：

   C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。实际上，很多语言中数组也并不是从 0 开始计数的，比如 Matlab。甚至还有一些语言支持负数下标，比如 Python。

### 4.二维数组内存寻址

对于 m * n 的数组，a\[ i ][ j ] (i < m,j < n)的地址为：

```
address = base_address + ( i * n + j) * type_size
```

### 5.JVM标记清除算法

1. 大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。

2. 不足：
   1. 效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效。
   2. 空间问题。会产生不连续的内存空间碎片。

## 4.代码

[int型数组源代码](https://github.com/wangzheng0822/algo/blob/master/java/05_array/Array.java)

[自定义数组源代码](https://github.com/Miyuki7/algo/blob/master/java/05_array/GenericArray.java)

``` java
/**
 * Created with IntelliJ IDEA.
 *
 * @Author: miyuki
 * @Date: 2022/11
 * @Description:我的ArrayList
 */
import java.util.Arrays;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class ArrayList<E> {
    /**
     * 元素的数量
     */
    private int size;
    /**
     * 所有的元素
     */
    private E[] elements;

    private static final int DEFAULT_CAPACITY = 10;
    private static final int ELEMENT_NOT_FOUND = -1;

    public ArrayList(int capaticy) {
        capaticy = (capaticy < DEFAULT_CAPACITY) ? DEFAULT_CAPACITY : capaticy;
        elements = (E[]) new Object[capaticy];
    }

    public ArrayList() {
        this(DEFAULT_CAPACITY);
    }

    /**
     * 清除所有元素
     */
    public void clear() {
        for (int i = 0; i < size; i++) {
            elements[i] = null;
        }
        size = 0;
    }

    /**
     * 元素的数量
     * @return
     */
    public int size() {
        return size;
    }

    /**
     * 是否为空
     * @return
     */
    public boolean isEmpty() {
        return size == 0;
    }

    /**
     * 是否包含某个元素
     * @param element
     * @return
     */
    public boolean contains(E element) {
        return indexOf(element) != ELEMENT_NOT_FOUND;
    }

    /**
     * 添加元素到尾部
     * @param element
     */
    public void add(E element) {
        add(size, element);
    }

    /**
     * 获取index位置的元素
     * @param index
     * @return
     */
    public E get(int index) {
        rangeCheck(index);
        return elements[index];
    }

    /**
     * 设置index位置的元素
     * @param index
     * @param element
     * @return 原来的元素ֵ
     */
    public E set(int index, E element) {
        rangeCheck(index);

        E old = elements[index];
        elements[index] = element;
        return old;
    }

    /**
     * 在index位置插入一个元素
     * @param index
     * @param element
     */
    public void add(int index, E element) {
        rangeCheckForAdd(index);

        ensureCapacity(size + 1);

        for (int i = size; i > index; i--) {
            elements[i] = elements[i - 1];
        }
        elements[index] = element;
        size++;
    }

    /**
     * 删除index位置的元素
     * @param index
     * @return
     */
    public E remove(int index) {
        rangeCheck(index);

        E old = elements[index];
        for (int i = index + 1; i < size; i++) {
            elements[i - 1] = elements[i];
        }
        elements[--size] = null;
        return old;
    }

    /**
     * 查看元素的索引
     * @param element
     * @return
     */
    public int indexOf(E element) {
        if (element == null) {  // 1
            for (int i = 0; i < size; i++) {
                if (elements[i] == null) return i;
            }
        } else {
            for (int i = 0; i < size; i++) {
                if (element.equals(elements[i])) return i; // n
            }
        }
        return ELEMENT_NOT_FOUND;
    }

//	public int indexOf2(E element) {
//		for (int i = 0; i < size; i++) {
//			if (valEquals(element, elements[i])) return i; // 2n
//		}
//		return ELEMENT_NOT_FOUND;
//	}
//
//	private boolean valEquals(Object v1, Object v2) {
//		return v1 == null ? v2 == null : v1.equals(v2);
//	}

    /**
     * 保证要有capacity的容量
     * @param capacity
     */
    private void ensureCapacity(int capacity) {
        int oldCapacity = elements.length;
        if (oldCapacity >= capacity) return;

        // 新容量为旧容量的1.5倍
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        E[] newElements = (E[]) new Object[newCapacity];
        for (int i = 0; i < size; i++) {
            newElements[i] = elements[i];
        }
        elements = newElements;

        System.out.println(oldCapacity + "扩容为" + newCapacity);
    }

    private void outOfBounds(int index) {
        throw new IndexOutOfBoundsException("Index:" + index + ", Size:" + size);
    }

    private void rangeCheck(int index) {
        if (index < 0 || index >= size) {
            outOfBounds(index);
        }
    }

    private void rangeCheckForAdd(int index) {
        if (index < 0 || index > size) {
            outOfBounds(index);
        }
    }

    @Override
    public String toString() {
        // size=3, [99, 88, 77]
        StringBuilder string = new StringBuilder();
        string.append("size=").append(size).append(", [");
        for (int i = 0; i < size; i++) {
            if (i != 0) {
                string.append(", ");
            }

            string.append(elements[i]);

//			if (i != size - 1) {
//				string.append(", ");
//			}
        }
        string.append("]");
        return string.toString();
    }

}

```



## 5.总结

数组是最基础、最简单的数据结构了。数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，==但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。==在平时的业务开发中，我们可以直接使用编程语言提供的容器类，但是，如果是特别底层的开发，直接使用数组可能会更合适。