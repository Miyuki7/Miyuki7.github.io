## 树的基本概念

![image-20221130140750551](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221130140750551.png)

生活中的树形结构

![image-20221130140846598](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221130140846598.png)

![image-20221130141307757](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221130141307757.png)

![image-20221130141453476](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221130141453476.png)

**有序树**：树中任意节点的子节点之间有顺序关系；

**无序树**：树中任意节点的子节点之间没有顺序关系，也称为 “自由树”；

**森林**：由 m（m ≥ 0）棵互不相交的树组成的集合；

## 二叉树（Binary Tree）

![image-20221130141913194](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221130141913194.png)

**二叉树是有序树**

### 二叉树的性质

![image-20221130142431606](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221130142431606.png)

### 真二叉树（Proper Binary Tree）

![image-20221130142625482](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221130142625482.png)

### 满二叉树（Full Binary Tree）

**满二叉树**：最后一层节点的度都为 0，其他节点的度都为 2

![image-20221130143011029](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221130143011029.png)

### 完全二叉树（Complete Binary Tree）

![image-20221201135056189](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221201135056189.png)

**完全二叉树**：对节点从上至下、左至右开始编号，其所有编号都能与相同高度的满二叉树中的编号对应

**完全二叉树的性质：**

![image-20221201135917233](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221201135917233.png)

![image-20221201140403377](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221201140403377.png)

![image-20221201140422113](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221201140422113.png)

**面试题**

![image-20221201142933928](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221201142933928.png)

![image-20221201143605973](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221201143605973.png)

国外教材的说法：了解一下

![image-20221201143847577](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221201143847577.png)

## 二叉树的遍历



![image-20221201180957783](C:\Users\14266\AppData\Roaming\Typora\typora-user-images\image-20221201180957783.png)

**遍历的应用**：

- 前序遍历：树状结构展示（注意左右子树的顺序）
- 中序遍历：二叉搜索树的中序遍历按升序或者降序处理节点
- 后序遍历：适用于一些先子后父的操作
- 层序遍历：计算二叉树的高度、判断一棵树是否为完全二叉树

### 前序遍历（Preorder Traversal）

访问顺序：**根**节点、前序遍历**左**子树、前序遍历**右**子树

下图**前序遍历**的结果是：7、4、2、1、3、5、9、8、11、10、12

![image-20221201184825819](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221201184825819.png)

二叉树的前序遍历：https://leetcode-cn.com/problems/binary-tree-preorder-traversal/

``` java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
	List<Integer> list = new ArrayList<>();
	public List<Integer> preorderTraversal(TreeNode root) {
        if(root == null) return list;
        
        list.add(root.val);
        preorderTraversal(root.left);
        preorderTraversal(root.right);
        
        return list;
    }
}
```

### 中序遍历（Inorder Traversal）

### ![image-20221201185850930](C:\Users\14266\AppData\Roaming\Typora\typora-user-images\image-20221201185850930.png)

![image-20221201185936907](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221201185936907.png)

二叉树的中序遍历： https://leetcode-cn.com/problems/binary-tree-inorder-traversal/

``` java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
	List<Integer> list = new ArrayList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
    	if(root == null) return list;
    	inorderTraversal(root.left);
    	list.add(root.val);
    	inorderTraversal(root.right);
    	return list;
    }
}
```



### 后序遍历（Postorder Traversal）

访问顺序：后序遍历**左**子树、后序遍历**右**子树、**根**节点

二叉树的后序遍历： https://leetcode-cn.com/problems/binary-tree-postorder-traversal/

``` java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
	List<Integer> list = new ArrayList<Integer>();
    public List<Integer> postorderTraversal(TreeNode root) {
        if(root == null) return list;
        postorderTraversal(root.left);
        postorderTraversal(root.right);
        list.add(root.val);
        return list;
    }
}
```

### 层序遍历（Level Order Traversal）

![image-20221201190835494](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221201190835494.png)

二叉树的层次遍历： https://leetcode-cn.com/problems/binary-tree-level-order-traversal/

``` java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
	List<List<Integer>> resList = new ArrayList<>();
    public List<List<Integer>> levelOrder(TreeNode root) {
    	if(root == null) return resList;
    	
    	Queue<TreeNode> queue = new LinkedList<>();
    	int levelSize = 1;
    	queue.offer(root);
    
    	
    	List<Integer> list = new ArrayList<>(); ;
    	while(!queue.isEmpty()){
    		TreeNode node = queue.poll();
    		list.add(node.val);
    		levelSize--;
    		
    		if(node.left != null){
    			queue.offer(node.left);
    		}
    		if(node.right != null){
    			queue.offer(node.right);
    		}

    		if(levelSize == 0){
    			resList.add(list);
                levelSize = queue.size();
    			list = new ArrayList<>();
    		}
    	}
    	return resList;
    }
}
```

### 重构遍历方法

可以利用策略模式，加一个visitor，用户可以自定义遍历时候的逻辑

```java
外部调用
bst.preorder(new Visitor<Integer>() {
			public boolean visit(Integer element) {
				System.out.print(element + " ");
				return element == 2 ? true : false;
			}
		});

类的内部加一个Vistor
public static abstract class Visitor<E> {
		boolean stop;
		/**
		 * @return 如果返回true，就代表停止遍历
		 */
		public abstract boolean visit(E element);
	}

public void preorder(Visitor<E> visitor) {
		if (visitor == null) return;
		preorder(root, visitor);
	}
	
	private void preorder(Node<E> node, Visitor<E> visitor) {
		if (node == null || visitor.stop) return;
		
		visitor.stop = visitor.visit(node.element);
		preorder(node.left, visitor);
		preorder(node.right, visitor);
	}
```

### 根据遍历结果重构二叉树

![image-20221201213222069](C:\Users\14266\AppData\Roaming\Typora\typora-user-images\image-20221201213222069.png)

### 遍历的应用

![image-20221201193807785](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221201193807785.png)