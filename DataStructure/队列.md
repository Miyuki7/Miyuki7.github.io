## 1.什么是队列？

1. 先进者先出，这就是典型的“队列”结构。
2. 支持两个操作：入队enqueue()，放一个数据到队尾；出队dequeue()，从队头取一个元素。
3. 所以，和栈一样，队列也是一种操作受限的线性表，用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。

## 2.实现队列

### 1.普通队列

#### 队列接口设计

``` java
int size(); // 元素的数量
boolean isEmpty(); // 是否为空
void clear(); // 清空
void enQueue(E element); // 入队
E deQueue(); // 出队
E front(); // 获取队列的头元素

```

队列的内部实现是否可以直接利用以前学过的[数据结构](https://so.csdn.net/so/search?q=数据结构&spm=1001.2101.3001.7020)？

- 动态数组、链表；
- 优先使用**双向链表**，因为队列主要是往头尾操作元素；

借助我们自己实现的双向链表来实现队列

```java

/**
 * 队列
 * 
 */
public class Queue <E>{
	private List<E> list = new LinkedList<>();
	
	/**
	 * 入队
	 */
	public void enQueue(E element){
		list.add(element);
	}
	/**
	 * 出队
	 */
	public E deQueue(){
		return list.remove(0);
	}
	/**
	 * 元素的数量
	 */
	public int size(){
		return list.size();
	}
	/**
	 * 清空
	 */
	public void clear(){
		list.clear();
	}
	/**
	 * 队头元素
	 */
	public E top(){
		return list.get(0);
	}
	/**
	 * 是否为空
	 */
	public boolean isEmpty(){
		return list.isEmpty();
	}
	
}

```

### 2.双端队列Deque

双端队列是能在**头尾**两端**添加、删除**的队列；

- 英文 deque 是 double ended queue 的简称；

#### 接口设计

``` java
int size(); // 元素的数量
boolean isEmpty(); // 是否为空
void clear(); // 清空
void enQueueRear(E element); // 从队尾入队
E deQueueFront(); // 从队头出队
void enQueueFront(E element); // 从队头入队
E deQueueRear(); // 从队尾出队
E front(); // 获取队列的头元素
E rear(); // 获取队列的尾元素

```

#### 队列代码

``` java
/**
 * 双端队列
 * @author yusael
 */
public class DeQueue <E> {
	// 双向链表实现双端队列
	private List<E> list = new LinkedList<>();
	/**
	 * 元素的数量
	 */
	public int size(){
		return list.size();
	}
	/**
	 * 是否为空
	 */
	public boolean isEmpty(){
		return list.isEmpty();
	}
	/**
	 * 清空
	 */
	public void clear(){
		list.clear();
	}
	/**
	 * 从队尾入队
	 */
	public void enQueueRear(E element){
		list.add(element);
	}
	/**
	 * 从队头入队
	 */
	public void enQueueFront(E element){
		list.add(0, element);
	}
	/**
	 * 从队尾出队
	 */
	public E deQueueRear(){
		return list.remove(list.size() - 1);
	}
	/**
	 * 从队头出队
	 */
	public E deQueueFront(){
		return list.remove(0);
	}
	/**
	 * 获取队列的头元素
	 */
	public E front(){
		return list.get(0);
	}
	/**
	 * 获取队里的尾元素
	 */
	public E rear(){
		return list.get(list.size() - 1);
	}
	
}
```



### 3.循环队列

![image-20221130000026468](https://cdn.jsdelivr.net/gh/Miyuki7/image-host/blog-imgimage-20221130000026468.png)

#### 代码实现

``` java
/**
 * 循环队列
 * @author yusael
 */
@SuppressWarnings("unchecked")
public class CircleQueue<E> {
	private int front; // 队头指针
	private int size; // 元素数量
	// 利用动态扩容数组实现的循环队列
	private E elements[]; // 元素
	public static final int DEFAULT_CAPACITY = 10; // 初始容量

	public CircleQueue() {
		elements = (E[]) new Object[DEFAULT_CAPACITY];
	}

	/**
	 * 元素的数量
	 */
	public int size() {
		return size;
	}

	/**
	 * 是否为空
	 */
	public boolean isEmpty() {
		return size == 0;
	}

	/**
	 * 清空
	 */
	public void clear() {
		for (int i = 0; i < size; i++) {
			// elements[index(i)] = null;
			elements[(i + front) %elements.length] = null;
		}
		size = 0;
		front = 0;
	}

	/**
	 * 从队头出队
	 */
	public E deQueue() {
		E fronElement = elements[front];
		elements[front] = null;
		front = (front + 1) % elements.length;
		// front = index(1);
		size--;
		return fronElement;
	}

	/**
	 * 从队尾入队
	 */
	public void enQueue(E element) {
		// 扩容
		ensureCapacity(size + 1);
		elements[(front + size) % elements.length] = element;
		// elements[index(size)] = element;
		size++;
	}

	/**
	 * 获取队列的头元素
	 */
	public E front() {
		return elements[front];
	}

	// 扩容
	private void ensureCapacity(int capacity) {
		int oldCapacity = elements.length;
		if (oldCapacity >= capacity)
			return;
		// 新容量为旧容量的 1.5 倍
		int newCapacity = oldCapacity + (oldCapacity >> 1);
		E[] newElements = (E[]) new Object[newCapacity];
		for (int i = 0; i < size; i++) { // 旧数组中元素移到新数组
			newElements[i] = elements[(i + front) % elements.length];
			// newElements[i] = elements[index(i)];
		}
		System.out.println("从" + oldCapacity + "扩容到" + newCapacity);
		elements = newElements;
		front = 0; // 重置front
	}

}

```

#### 索引映射封装

可以发现循环队列中经常有 (front + size) % elements.length 的操作，那是因为如果 front 在队尾了，而又要往后移则会回到开头，该代码就是根据 front 的真实索引计算出在循环队列上的索引。

我们可以将这个封装为一个方法，实际上这个写法使用 % 运算符，性能十分低，后面会对此做优化。

``` java
// 将front真实索引转换为循环队列上的索引
private int index(int index) {
	 return (front + index) % elements.length;
}

```

则循环队列中的其他方法可以修改为如下：

``` java
/**
 * 清空
 */
public void clear() {
	for (int i = 0; i < size; i++) {
		elements[index(i)] = null;
	}
	size = 0;
	front = 0;
}

```

``` java
/**
 * 从队头出队
 */
public E deQueue() {
	E fronElement = elements[front];
	elements[front] = null;
	front = index(1);
	size--;
	return fronElement;
}

```

``` java
/**
 * 从队尾入队
 */
public void enQueue(E element) {
	// 扩容
	ensureCapacity(size + 1);
	elements[index(size)] = element;
	size++;
}

```

#### 循环队列 – %运算符优化

尽量避免使用 **乘*、除/、模%、浮点数运算**，效率低下；

**原理**：已知 n >= 0，m > 0：

* `n % m` 等价于 `n – (m > n ? 0 : m)` ；
  前提条件：`n < 2m`

由于我们已经封装了索引映射的方法，%运算符优化只需要修改 index 方法即可：

``` java
// 将真实索引转换为循环队列上的索引
private int index(int index) {
	// 10%8 = 2 10-8=2
	// 10%11 = 10 10
	index += front;
	return index - ((index >= elements.length) ? elements.length : 0);
}
```

#### 完整代码

``` java
/**
 * 循环队列
 * @author yusael
 */
@SuppressWarnings("unchecked")
public class CircleQueue<E> {
	private int front; // 队头指针
	private int size; // 元素数量
	// 利用动态扩容数组实现的循环队列
	private E elements[]; // 元素
	public static final int DEFAULT_CAPACITY = 10; // 初始容量

	public CircleQueue() {
		elements = (E[]) new Object[DEFAULT_CAPACITY];
	}

	/**
	 * 元素的数量
	 */
	public int size() {
		return size;
	}

	/**
	 * 是否为空
	 */
	public boolean isEmpty() {
		return size == 0;
	}

	/**
	 * 清空
	 */
	public void clear() {
		// while(size >= 0){
		// elements[(front+size)%elements.length] = null;
		// size--;
		// }
		for (int i = 0; i < size; i++) {
			elements[index(i)] = null;
		}
		size = 0;
		front = 0;
	}

	/**
	 * 从队头出队
	 */
	public E deQueue() {
		E fronElement = elements[front];
		elements[front] = null;
		// front = (front + 1) %elements.length;
		front = index(1);
		size--;
		return fronElement;
	}

	/**
	 * 从队尾入队
	 */
	public void enQueue(E element) {
		// 扩容
		ensureCapacity(size + 1);
		// elements[(front + size) % elements.length] = element;
		elements[index(size)] = element;
		size++;
	}

	/**
	 * 获取队列的头元素
	 */
	public E front() {
		return elements[front];
	}

	// 将真实索引转换为循环队列上的索引
	private int index(int index) {
		// 10%8 = 2 10-8=2
		// 10%11 = 10 10
//		return (front + index) % elements.length;
		index += front;
		return index - ((index >= elements.length) ? elements.length : 0);
	}

	// 扩容
	private void ensureCapacity(int capacity) {
		int oldCapacity = elements.length;
		if (oldCapacity >= capacity)
			return;
		// 新容量为旧容量的 1.5 倍
		int newCapacity = oldCapacity + (oldCapacity >> 1);
		E[] newElements = (E[]) new Object[newCapacity];
		for (int i = 0; i < size; i++) { // 旧数组中元素移到新数组
			// 	newElements[i] = elements[(i + front) % elements.length];
			newElements[i] = elements[index(i)];
		}
		System.out.println("从" + oldCapacity + "扩容到" + newCapacity);
		elements = newElements;
		front = 0; // 重置front
	}

	@Override
	public String toString() {
		StringBuilder string = new StringBuilder();
		string.append("capcacity=").append(elements.length).append(" size=").append(size).append(" front=")
				.append(front).append(", [");
		for (int i = 0; i < elements.length; i++) {
			if (i != 0) {
				string.append(", ");
			}
			string.append(elements[i]);
		}
		string.append("]");
		return string.toString();
	}

}

```

#### 代码测试

``` java
public static void main(String[] args) {
	CircleQueue<Integer> queue = new CircleQueue<Integer>();
	// 0 1 2 3 4 5 6 7 8 9
	for (int i = 0; i < 10; i++) {
		queue.enQueue(i);
	}
	// null null null null null 5 6 7 8 9
	for (int i = 0; i < 5; i++) {
		queue.deQueue();
	}
	// 15 16 17 18 19 f[5] 6 7 8 9
	for (int i = 15; i < 30; i++) {
		queue.enQueue(i);
	}
//		while (!queue.isEmpty()) {
//			System.out.println(queue.deQueue());
//		}
//		queue.clear();
	System.out.println(queue);
}

```



### 4.循环双端队列

循环双端队列：可以进行两端添加、删除操作的循环队列；

循环队列中用了 `front` 指针来表示队列的头部，双端循环队列是否需要再使用一个 `rear` 指针来表示队列的尾部?

* 不需要，只要有了头指针便可以算出尾部；

首先理解一下循环双端队列中索引封装映射：

* 传入的 `index` 是相对于 `front` 的索引，返回的是真实的索引：
  比如要获得 头部指针 的前一位，则是 `index(-1)`（用于队头入队）
  比如要获得 尾部指针，则是 `index(size - 1)`

``` java
private int index(int index) {
	index += front;
	if (index < 0) { // index 为负数
		return index + elements.length;
	}
	// index 为正数
	return index % elements.length;
}
```

#### 循环双端队列实现

``` java
package com.mj.circle;

/**
 * 循环双端队列
 * @author yusael
 */
@SuppressWarnings("unchecked")
public class CircleDeque<E> {
	private int front; // 队头指针
	private int size; // 元素数量
	private E elements[]; // 元素
	public static final int DEFAULT_CAPACITY = 10; // 初始容量

	public CircleDeque() {
		elements = (E[]) new Object[DEFAULT_CAPACITY];
	}

	/**
	 * 元素的数量
	 */
	public int size() {
		return size;
	}

	/**
	 * 是否为空
	 */
	public boolean isEmpty() {
		return size == 0;
	}

	/**
	 * 清空
	 */
	public void clear() {
		for (int i = 0; i < size; i++) {
			elements[index(i)] = null;
		}
		front = 0;
		size = 0;
	}

	/**
	 * 从队尾入队
	 */
	public void enQueueRear(E element) {
		// 头 1 r(2) null null null f(6) 7 8 9 尾
		ensureCapacity(size + 1);

		elements[index(size)] = element;
		size++;
	}

	/**
	 * 从队头入队
	 */
	public void enQueueFront(E element) {
		ensureCapacity(size + 1);

		front = index(-1);
		elements[front] = element;
		size++;
	}

	/**
	 * 从队尾出队
	 */
	public E deQueueRear() {
		int rearIndex = index(size - 1);
		E rear = elements[rearIndex];
		elements[rearIndex] = null;
		size--;
		return rear;
	}

	/**
	 * 从队头出队
	 */
	// 头 1 r(2) null null f(5) 6 7 8 9 尾
	public E deQueueFront() {
		E frontElement = elements[front];
		elements[front] = null;
		front = index(1);
		size--;
		return frontElement;
	}

	/**
	 * 获取队列的头元素
	 */
	public E front() {
		return elements[front];
	}

	/**
	 * 获取队列的尾元素
	 */
	public E rear() {
		return elements[index(size - 1)];
	}

	// 索引封装映射
	private int index(int index) {
		index += front;
		if (index < 0) { // index 为负数
			return index + elements.length;
		}
		// index 为正数
		return index % elements.length;
	}

	// 数组扩容
	private void ensureCapacity(int capacity) {
		int oldCapacity = elements.length;
		if (oldCapacity >= capacity)
			return;

		int newCapacity = oldCapacity + (oldCapacity >> 1); // 扩容为1.5倍
		E newElements[] = (E[]) new Object[newCapacity];
		for (int i = 0; i < size; i++) {
			newElements[i] = elements[index(i)];
		}
		elements = newElements;
		front = 0; // 重置front
	}
}

```

#### 循环队列 – %运算符优化

尽量避免使用 **乘*、除/、模%、浮点数运算**，效率低下；

**原理**：已知 n >= 0，m > 0：

* `n % m` 等价于 `n – (m > n ? 0 : m)` ；
  前提条件：`n < 2m`

由于我们已经封装了索引映射的方法，%运算符优化只需要修改 index 方法即可：

``` java
// 索引封装映射
private int index(int index) {
	index += front;
	if (index < 0) { // index 为负数
		return index + elements.length;
	}
	// index 为正数
	return index % elements.length;
}

```

#### 完整代码

``` java
package com.mj.circle;

/**
 * 循环双端队列
 * @author yusael
 */
@SuppressWarnings("unchecked")
public class CircleDeque <E> {	
	private int front; // 队头指针
	private int size;  // 元素数量
	private E elements[]; // 元素
	public static final int DEFAULT_CAPACITY = 10; // 初始容量

	public CircleDeque() {
		elements = (E[]) new Object[DEFAULT_CAPACITY];
	}
	/**
	 * 元素的数量
	 */
	public int size(){
		return size;
	}
	/**
	 * 是否为空
	 */
	public boolean isEmpty(){
		return size == 0;
	}
	/**
	 * 清空
	 */
	public void clear(){
		for(int i = 0; i < size; i++){
			elements[index(i)] = null;
		}
		front = 0;
		size = 0;
	}
	/**
	 * 从队尾入队
	 */
	public void enQueueRear(E element){
		// 头 1 r(2) null null null f(6) 7 8 9  尾
		 ensureCapacity(size + 1);
		 
		elements[index(size)] = element;
		size++;
	}
	/**
	 * 从队头入队
	 */
	public void enQueueFront(E element){
		ensureCapacity(size + 1);
		
		/*if(front - 1 < 0){
			front += elements.length;
		}
		front = front - 1;
		elements[front-1] = element;*/
		
		front = index(-1);
		elements[front] = element;
		size++;
	}
	/**
	 * 从队尾出队
	 */
	public E deQueueRear(){
		E rearElement = elements[(front+size-1)%elements.length];
		elements[(front+size-1)%elements.length] = null;
		size--;
		return rearElement;
	}
	/**
	 * 从队头出队
	 */
	// 头 1 r(2) null null f(5) 6 7 8 9  尾
	public E deQueueFront() {
		E frontElement = elements[front];
		elements[front] = null;
		front = index(1);
		size--;
		return frontElement;
	}
	/**
	 * 获取队列的头元素
	 */
	public E front(){
		return elements[front];
	}
	/**
	 * 获取队列的尾元素
	 */
	public E rear(){
		return elements[index(size - 1)];
	}
	// 索引封装映射
	private int index(int index) {
		index += front;
		if (index < 0) {
			return index + elements.length;
		}
		return index - ((index >= elements.length) ? elements.length : 0);
	}
	// 数组扩容
	private void ensureCapacity(int capacity){
		int oldCapacity = elements.length;
		if(oldCapacity >= capacity) return;
		
		int newCapacity = oldCapacity + (oldCapacity >> 1); // 扩容为1.5倍
		E newElements[] = (E[]) new Object[newCapacity];
		for(int i = 0; i < size; i++){
			newElements[i] = elements[index(i)];
		}
		elements = newElements;
		front = 0; // 重置front
	}
	@Override
	public String toString() {
		StringBuilder string = new StringBuilder();
		string.append("capcacity=").append(elements.length)
		.append(" size=").append(size)
		.append(" front=").append(front)
		.append(", [");
		for (int i = 0; i < elements.length; i++) {
			if (i != 0) {
				string.append(", ");
			}
			
			string.append(elements[i]);
		}
		string.append("]");
		return string.toString();
	}
}

```

#### 循环双端队列测试

``` java
public static void main(String[] args) {
	CircleDeque<Integer> queue = new CircleDeque<>();
	// 头5 4 3 2 1  100 101 102 103 104 105 106 8 7 6 尾
	
	// 头 8 7 6  5 4 3 2 1  100 101 102 103 104 105 106 107 108 109 null null 10 9 尾
	for (int i = 0; i < 10; i++) {
		queue.enQueueFront(i + 1);
		queue.enQueueRear(i + 100);
	}
	
	// 头 null 7 6  5 4 3 2 1  100 101 102 103 104 105 106 null null null null null null null 尾
	for (int i = 0; i < 3; i++) {
		queue.deQueueFront();
		queue.deQueueRear();
	}
	
	// 头 11 7 6  5 4 3 2 1  100 101 102 103 104 105 106 null null null null null null 12 尾
	queue.enQueueFront(11);
	queue.enQueueFront(12);
	System.out.println(queue);
//		while (!queue.isEmpty()) {
//			System.out.println(queue.deQueueFront());
//		}
}

```



## 3.队列有哪些常见的应用？

1.阻塞队列
1）在队列的基础上增加阻塞操作，就成了阻塞队列。
2）阻塞队列就是在队列为空的时候，从队头取数据会被阻塞，因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后在返回。
3）从上面的定义可以看出这就是一个“生产者-消费者模型”。这种基于阻塞队列实现的“生产者-消费者模型”可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了，这时生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续生产。不仅如此，基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据处理效率，比如配置几个消费者，来应对一个生产者。
2.并发队列
1）在多线程的情况下，会有多个线程同时操作队列，这时就会存在线程安全问题。能够有效解决线程安全问题的队列就称为并发队列。
2）并发队列简单的实现就是在enqueue()、dequeue()方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或取操作。
3）实际上，基于数组的循环队列利用CAS原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。
3.线程池资源枯竭是的处理
在资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。

## 4.总结

队列最大的特点就是先进先出，主要的两个操作是入队和出队。跟栈一样，它既可以用数组来实现，也可以用链表来实现。用数组实现的叫顺序队列，用链表实现的叫链式队列。特别是长得像一个环的循环队列。在数组实现队列的时候，会有数据搬移操作，要想解决数据搬移的问题，我们就需要像环一样的循环队列。

循环队列是重点。要想写出没有 bug 的循环队列实现代码，关键要确定好队空和队满的判定条件。

阻塞队列、并发队列，底层都还是队列这种数据结构，只不过在之上附加了很多其他功能。阻塞队列就是入队、出队操作可以阻塞，并发队列就是队列的操作多线程安全。

1. 除了线程池这种池结构会用到队列排队请求，你还知道有哪些类似的池结构或者场景中会用到队列的排队请求呢？

   答：分布式应用中的消息队列，也是一种队列结构

2. 今天讲到并发队列，关于如何实现无锁并发队列，网上有非常多的讨论。对这个问题，你怎么看呢？

   答：考虑使用CAS实现无锁队列，则在入队前，获取tail位置，入队时比较tail是否发生变化，如果否，则允许入队，反之，本次入队失败。出队则是获取head位置，进行cas。

## 5.实现代码

[队列](https://github.com/wangzheng0822/algo/tree/master/java/09_queue)

